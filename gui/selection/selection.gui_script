


function init(self)
    
	--msg.post(".", "acquire_input_focus")
	
	self.massSelectionMode=false
	
	self.pressedSinceLast=false
	self.releasedSinceLast=true
	self.rightPressedSinceLast=false
	
	self.parseInput=function(self, action_id, action)
	
			if action_id==hash("rightClicked") and action.released and self.rightPressedSinceLast then
				self.rightPressedSinceLast=false
				
				--[[
					1) find one movable unit
					2) compute the path for that unit
					3) give that path to the rest of the selection
				--]]
				
				local foundAPathForWholeSelection=false
				local pathFound={}
				local leadingUnit={}
				
				for unit,isSelected in pairs(SELECTED_UNITS) do 
					--key is the GO, value is true/nil
					if isSelected==true and unit.movableUnit then
						
						if foundAPathForWholeSelection==false then
							generateNewPathToMouseClick(unit,action,tilemap)
							pathFound=unit.currentPath
							foundAPathForWholeSelection=true
							leadingUnit=unit
						else
							--only follow leader if near leader
							if math.abs(unit.x-leadingUnit.x)<200 and math.abs(unit.y-leadingUnit.y)<200 then
								loadPath(unit,pathFound)
							else --otherwise find own path
								generateNewPathToMouseClick(unit,action,tilemap)
							end
						end
						
						unit.isFighting=false
						unit.followee=nil
					else
						print("not movable selected unit!")
					end
				end
				
			elseif action_id==hash("rightClicked") and action.pressed then
				self.rightPressedSinceLast=true
			end
			
			--this is called only when left click first time
			if action_id==hash("leftClicked") and action.pressed and self.releasedSinceLast then
				--mouse variables are in manager.script
				mouseDown=true
				
				self.pressedSinceLast=true
				self.releasedSinceLast=false
				
				--save where the user first clicked
				if savedMouseDownCoordinates~=true then
					mouseDownStartCoordinates={action.x,action.y}
					savedMouseDownCoordinates=true
				end
				
			
			
			--reset variables when mouse is released
			elseif action_id==hash("leftClicked") and action.released and self.pressedSinceLast then
				mouseDown=false
				savedMouseDownCoordinates=false
				hideSelection()
				
				self.pressedSinceLast=false
				self.releasedSinceLast=true
				
				--if no mass selection, pretend we have a selection of 1x1 and only one unit will be selected
				if self.massSelectionMode~=true and GUI_CLICKED==false then
					
					msg.post("manager","deselectAll",{})
					msg.post("manager","massSelection",{start=mouseDownStartCoordinates,
														current={mouseDownStartCoordinates[1]+1,mouseDownStartCoordinates[2]+1},
														pivot=gui.get_pivot(gui.get_node("selectionBox"))})
				end
				
				
				self.massSelectionMode=false
			
			
			--this is called when the user moves the mouse while pressing down
			elseif mouseDown and GUI_CLICKED==false then
					
				--show selection only when the user has moved the mouse from the point he first clicked
				if(action.x~=mouseDownStartCoordinates[1] or action.y~=mouseDownStartCoordinates[2])then
					
					showSelection(mouseDownStartCoordinates,{action.x,action.y})
					
					if self.massSelectionMode~=true then
						self.massSelectionMode=true
						msg.post("manager","deselectAll",{})
					end
					
					--send the selection to the manager.script and manager will send it to all selectable units
					--the units will decide if they should be selected
					
					msg.post("manager","massSelection",{start=mouseDownStartCoordinates,
														current={action.x,action.y},
														pivot=gui.get_pivot(gui.get_node("selectionBox"))})
					
				end
			
			end  
	end
	
	hideSelection()
	
end

function showSelection(startCoordinates, currentCoordinates)
	
	--change where we start drawing the selection depending on where the user dragged
	
	if startCoordinates[2] > currentCoordinates[2] then
		--the user dragged down so it should be NE or NW depending if the user drags left or right
		if startCoordinates[1] > currentCoordinates[1] then
			gui.set_pivot(gui.get_node("selectionBox"),gui.PIVOT_NE)
		else
			gui.set_pivot(gui.get_node("selectionBox"),gui.PIVOT_NW)
		end
	else
		--the user dragged up so it should be SE or SW depending if the user drags left or right
		if startCoordinates[1] > currentCoordinates[1] then
			gui.set_pivot(gui.get_node("selectionBox"),gui.PIVOT_SE)
		else
			gui.set_pivot(gui.get_node("selectionBox"),gui.PIVOT_SW)
		end
	end
	
	--now we've dealt with the pivot-points, now we need to adjust the size
	
	local height = math.abs(startCoordinates[2]-currentCoordinates[2])
	local width = math.abs(startCoordinates[1]-currentCoordinates[1])

	--set size, position and color
	gui.set_position(gui.get_node("selectionBox"), vmath.vector3(startCoordinates[1], startCoordinates[2], 1))
	gui.set_size(gui.get_node("selectionBox"), vmath.vector3(width, height, 1))
	gui.set_color(gui.get_node("selectionBox"), vmath.vector4(0, 1, 0, 0.5))
	
end

function hideSelection()
	 gui.set_color(gui.get_node("selectionBox"), vmath.vector4(0, 0, 0, 0))
end

function final(self)
    -- Add finalization code here
    -- Remove this function if not needed
end

function update(self, dt)
    -- Add update code here
    -- Remove this function if not needed
    
 
    
end

function on_message(self, message_id, message, sender)
    
    if message_id==hash("newInput") then
    	self.parseInput(self, message.action_id, message.action)
    end
    
end


function on_reload(self)
    -- Add input-handling code here
    -- Remove this function if not needed
end
